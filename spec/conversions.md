---
ms.openlocfilehash: 7aef52145a71bff1d489772e81eb786a9dbd23d1
ms.sourcegitcommit: 0e8c2550c052934e02defb6d6eb9f322e061b674
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/14/2019
ms.locfileid: "72306191"
---
# <a name="conversions"></a>変換

変換とは、ある型から別の型に値を変更する処理のことです。 たとえば、`Integer` 型の値を型 `Double` の値に変換したり、@no__t 型の値を `Base` 型の値に変換したりすることができます。これは、@no__t と @no__t が両方ともクラスで、@no__t が @no__t から継承していることを前提としています。 変換では、値自体を変更する必要がない場合があります (後者の例のように)。または、(前の例のように) 値表現に大きな変更が必要になる場合があります。

変換は、拡大または縮小することができます。 *拡大変換*とは、ある型から別の型への変換のことです。この型は、値ドメインが元の型の値ドメインよりも大きい場合は、少なくとも大きくなります。 拡大変換は失敗しません。 *縮小変換*は、型から別の型への変換で、値ドメインが元の型の値ドメインよりも小さいか、または変換時に余分な注意が必要である (変換する場合など)。`Integer` から `String`) になります。 情報の損失を伴う可能性がある縮小変換は失敗する可能性があります。

Id 変換 (型からそれ自体への変換) と既定値の変換 (つまり、`Nothing` からの変換) は、すべての型に対して定義されます。

## <a name="implicit-and-explicit-conversions"></a>暗黙の型変換と明示的な型変換

変換は、*暗黙的*または*明示的*に行うことができます。 暗黙の型変換は、特別な構文を使用せずに発生します。 次に示すのは、`Integer` 値から `Long` 値への暗黙的な変換の例です。

```vb
Module Test
    Sub Main()
        Dim intValue As Integer = 123
        Dim longValue As Long = intValue

        Console.WriteLine(intValue & " = " & longValue)
    End Sub
End Module
```

一方、明示的な変換では、キャスト演算子が必要です。 Cast 演算子を使用せずに値に対して明示的な変換を実行しようとすると、コンパイル時エラーが発生します。 次の例では、明示的な変換を使用して、@no__t 0 の値を `Integer` の値に変換します。

```vb
Module Test
    Sub Main()
        Dim longValue As Long = 134
        Dim intValue As Integer = CInt(longValue)

        Console.WriteLine(longValue & " = " & intValue)
    End Sub
End Module
```

暗黙的な変換のセットは、コンパイル環境と `Option Strict` ステートメントによって異なります。 厳密なセマンティクスが使用されている場合、暗黙的に拡張変換のみが発生する可能性があります。 寛容なセマンティクスが使用されている場合、すべての拡大変換および縮小変換 (つまり、すべての変換) が暗黙的に発生する可能性があります。

## <a name="boolean-conversions"></a>ブール型変換

@No__t-0 は数値型ではありませんが、列挙型であるかのように、数値型との間で縮小変換が行われます。 リテラル `True` は `Byte` の場合は `255`、@no__t の場合は `65535`、@no__t 6 の場合は @no__t @no__t、@no__t の場合は-9、2、3、4、5 のようにリテラルに変換されます。、および 6 です。 リテラル `False` はリテラル `0` に変換されます。 0の数値は、リテラル `False` に変換されます。 その他のすべての数値は、リテラル `True` に変換されます。

ブール値から文字列への縮小変換は、`System.Boolean.TrueString` または `System.Boolean.FalseString` のいずれかに変換されます。 @No__t-0 から `Boolean` への縮小変換もあります。文字列が `TrueString` または `FalseString` (現在のカルチャでは区別) と等しい場合は、適切な値が使用されます。それ以外の場合は、文字列を数値型として解析しようとします (可能な場合は16進数または8進数、それ以外の場合は float)。それ以外の場合は `System.InvalidCastException` がスローされます。

## <a name="numeric-conversions"></a>数値変換

数値変換は、型 `Byte`、`SByte`、`UShort`、`Short`、`UInteger`、`Integer`、`ULong`、`Long`、`Decimal`、`Single`、0、およびすべての列挙型の間に存在します。 変換されるとき、列挙型は基になる型として扱われます。 列挙型に変換する場合、ソース値は列挙型で定義されている値のセットに準拠している必要はありません。 以下に例を示します。

```vb
Enum Values
    One
    Two
    Three
End Enum

Module Test
    Sub Main()
        Dim x As Integer = 5

        ' OK, even though there is no enumerated value for 5.
        Dim y As Values = CType(x, Values)
    End Sub
End Module
```

数値変換は、次のように実行時に処理されます。

* 数値型からより広い数値型への変換では、値は単純により広い型に変換されます。 @No__t-0、`Integer`、`ULong`、`Long`、または @no__t から @no__t への変換は、最も近い `Single` または `Double` の値に丸められます。 この変換によって有効桁数が失われる可能性がありますが、マグニチュードが失われることはありません。

* 整数型から別の整数型への変換、または `Single`、`Double`、または `Decimal` から整数型への変換の場合、結果は整数オーバーフローチェックがオンかどうかによって異なります。

  *整数オーバーフローを確認する場合は、次のようになります。*

  * ソースが整数型の場合、変換元の引数が変換先の型の範囲内にある場合、変換は成功します。 変換元の引数が変換先の型の範囲外にある場合、変換は `System.OverflowException` 例外をスローします。

  * ソースが `Single`、`Double`、または `Decimal` の場合は、基になる値が最も近い整数値に切り上げられます。この整数値は変換の結果になります。 ソース値が2つの整数値に均等に近い場合、値は、最下位桁の位置にある偶数を持つ値に丸められます。 結果の整数値が変換先の型の範囲外にある場合は、`System.OverflowException` 例外がスローされます。

  *整数オーバーフローがチェックされていない場合は、次のようになります。*

  * ソースが整数型の場合、変換は常に成功し、ソース値の最上位ビットを破棄するだけで構成されます。

  * ソースが `Single`、`Double`、または `Decimal` の場合、変換は常に成功し、最も近い整数値に対するソース値の丸め処理が行われます。 ソース値が2つの整数値に均等に近い場合、値は常に、最下位桁の位置にある偶数の値に丸められます。

* @No__t-0 から `Single` への変換の場合、`Double` の値は最も近い `Single` の値に丸められます。 @No__t 0 の値が小さすぎて `Single` として表現できない場合、結果は正のゼロまたは負のゼロになります。 @No__t 0 の値が、`Single` として表すには大きすぎる場合、結果は正の無限大または負の無限大になります。 @No__t 0 の値が `NaN` の場合、結果も `NaN` になります。

* @No__t-0 または `Double` から `Decimal` への変換では、ソース値は `Decimal` 表現に変換され、必要に応じて28桁の小数点以下の最も近い数値に丸められます。 ソース値が小さすぎて @no__t 0 として表すことができない場合、結果は0になります。 ソース値が `NaN`、無限大、または大きすぎて `Decimal` として表すことができない場合は、`System.OverflowException` 例外がスローされます。

* @No__t-0 から `Single` への変換の場合、`Double` の値は最も近い `Single` の値に丸められます。 @No__t 0 の値が小さすぎて `Single` として表現できない場合、結果は正のゼロまたは負のゼロになります。 @No__t 0 の値が、`Single` として表すには大きすぎる場合、結果は正の無限大または負の無限大になります。 @No__t 0 の値が `NaN` の場合、結果も `NaN` になります。

## <a name="reference-conversions"></a>参照変換

参照型は基本型に変換できますが、その逆も可能です。 変換される値が null 値、派生型自体、またはより派生型である場合、基本型からより派生型への変換は実行時にのみ成功します。

クラス型とインターフェイス型は、任意のインターフェイス型との間でキャストできます。 型とインターフェイス型の間の変換は、関連する実際の型が継承または実装関係を持つ場合にのみ、実行時に成功します。 インターフェイス型には、常に @no__t から派生した型のインスタンスが含まれているため、インターフェイス型も `Object` との間で常にキャストできます。

__付箋.__ COM クラスを表すクラスには、実行時までわからないインターフェイスの実装が含まれている可能性があるため、`NotInheritable` クラスを実装していないインターフェイスとの間で変換することはできません。 

実行時に参照変換が失敗した場合は、@no__t 0 の例外がスローされます。

### <a name="reference-variance-conversions"></a>参照の分散変換

ジェネリックインターフェイスまたはデリゲートは、型の互換性のあるバリアント間の変換を可能にするバリアント型パラメーターを持つことができます。 したがって、実行時に、クラス型またはインターフェイス型から、派生したインターフェイス型またはを実装するインターフェイス型との互換性を持つインターフェイス型への変換は成功します。 同様に、デリゲート型は、バリアント互換のデリゲート型との間でキャストできます。 たとえば、デリゲート型

```vb
Delegate Function F(Of In A, Out R)(a As A) As R
```

`F(Of Object, Integer)` から `F(Of String, Integer)` への変換を許可します。 つまり、`Object` を受け取るデリゲート @no__t 0 は、`String` を受け取るデリゲート @no__t として安全に使用される場合があります。 デリゲートが呼び出されると、ターゲットメソッドはオブジェクトを想定し、文字列はオブジェクトになります。

一般的なデリゲートまたはインターフェイス型 `S(Of S1,...,Sn)` は、ジェネリックインターフェイスまたはデリゲート @no__t 型との*バリアント互換*であると言います。

* `S` および `T` は、両方とも同じジェネリック型 `U(Of U1,...,Un)` から構築されています。

* 型パラメーターごとに `Ux`:

  * 型パラメーターが variance なしで宣言されている場合、`Sx` と `Tx` は同じ型である必要があります。

  * 型パラメーターが @no__t として宣言されている場合は、拡張 id、既定値、参照、配列、または型パラメーターを `Sx` から `Tx` に変換する必要があります。

  * 型パラメーターが @no__t として宣言されている場合は、拡張 id、既定値、参照、配列、または型パラメーターを `Tx` から `Sx` に変換する必要があります。

クラスからバリアント型パラメーターを持つジェネリックインターフェイスに変換するときに、クラスが複数のバリアント互換インターフェイスを実装する場合、バリアント以外の変換がない場合、変換はあいまいです。 以下に例を示します。

```vb
Class Base
End Class

Class Derived1
    Inherits Base
End Class

Class Derived2
    Inherits Base
End Class

Class OneAndTwo
    Implements IEnumerable(Of Derived1)
    Implements IEnumerable(Of Derived2)
End Class

Class BaseAndOneAndTwo
    Implements IEnumerable(Of Base)
    Implements IEnumerable(Of Derived1)
    Implements IEnumerable(Of Derived2)
End Class

Module Test
    Sub Main()
        ' Error: conversion is ambiguous
        Dim x As IEnumerable(Of Base) = New OneAndTwo()

        ' OK, will pick up the direct implementation of IEnumerable(Of Base)
        Dim y as IEnumerable(Of Base) = New BaseAndOneAndTwo()
    End Sub
End Module
```

### <a name="anonymous-delegate-conversions"></a>匿名デリゲートの変換

ラムダメソッドとして分類された式が、対象の型が存在しないコンテキスト (`Dim x = Function(a As Integer, b As Integer) a + b` など) の値として再分類される場合、または対象の型がデリゲート型ではない場合、結果の式の型は、それに相当する匿名デリゲート型になります。ラムダメソッドのシグネチャ。 この匿名デリゲート型は、互換性のある任意のデリゲート型への変換を含んでいます。互換性のあるデリゲート型は、匿名デリゲート型の `Invoke` メソッドをパラメーターとして持つデリゲート作成式を使用して作成できる任意のデリゲート型です。 以下に例を示します。

```vb
' Anonymous delegate type similar to Func(Of Object, Object, Object)
Dim x = Function(x, y) x + y

' OK because delegate type is compatible
Dim y As Func(Of Integer, Integer, Integer) = x
```

@No__t-0 および `System.MulticastDelegate` の型は、それ自体がデリゲート型とは見なされないことに注意してください (すべてのデリゲート型がそれらを継承する場合でも)。 また、匿名デリゲート型から互換性のあるデリゲート型への変換は、参照変換ではないことに注意してください。

## <a name="array-conversions"></a>配列の変換

配列に定義されている変換に加えて、参照型であるという事実によって、配列に対していくつかの特殊な変換が存在します。

@No__t-0 および `B` の2つの型では、それらが参照型または値型として知られていない型パラメーターの両方であり、`A` が参照、配列、または型パラメーターが `B` に変換されている場合、@no__t 型の配列からの配列に変換が存在します。同じ順位の `B` を入力します。 このリレーションシップは、*配列の共変性*と呼ばれます。 配列の共変性は特に、要素型が @no__t である配列の要素は、実際には要素型が @no__t である配列の要素である場合があります。これは `A` と `B` の両方が参照型で、@no__t が参照を持っている場合に発生します。`A` への変換または配列変換。 次の例では、`F` の2回目の呼び出しによって `System.ArrayTypeMismatchException` 例外がスローされます。これは `b` の実際の要素の型が `String` であり、@no__t ではないためです。

```vb
Module Test
    Sub F(ByRef x As Object)
    End Sub

    Sub Main()
        Dim a(10) As Object
        Dim b() As Object = New String(10) {}
        F(a(0)) ' OK.
        F(b(1)) ' Not allowed: System.ArrayTypeMismatchException.
   End Sub
End Module
```

配列の共変性により、参照型の配列の要素への代入には、配列要素に割り当てられている値が実際に許可されている型であることを保証するランタイムチェックが含まれます。

```vb
Module Test
    Sub Fill(array() As Object, index As Integer, count As Integer, _
            value As Object)
        Dim i As Integer

        For i = index To (index + count) - 1
            array(i) = value
        Next i
    End Sub

    Sub Main()
        Dim strings(100) As String

        Fill(strings, 0, 101, "Undefined")
        Fill(strings, 0, 10, Nothing)
        Fill(strings, 91, 10, 0)
    End Sub
End Module
```

この例では、メソッド `Fill` の `array(i)` への代入には、変数 `value` によって参照されるオブジェクトが `Nothing` であるか、配列の実際の要素型と互換性のある型のインスタンスであることを保証するランタイムチェックが暗黙的に含まれてい @no__ t-4。 メソッド `Main` の場合、@no__t メソッドの最初の2回の呼び出しは成功しますが、3回目の呼び出しでは、最初の割り当てを実行したときに `System.ArrayTypeMismatchException` の例外がスローされ、`array(i)` になります。 この例外は、`String` の配列に @no__t 0 を格納できないために発生します。

配列要素の型の1つが、実行時に型が値型である型パラメーターである場合は、@no__t 0 の例外がスローされます。 以下に例を示します。

```vb
Module Test
    Sub F(Of T As U, U)(x() As T)
        Dim y() As U = x
    End Sub

    Sub Main()
        ' F will throw an exception because Integer() cannot be
        ' converted to Object()
        F(New Integer() { 1, 2, 3 })
    End Sub
End Module
```

また、配列のランクが同じ場合は、列挙型の配列と、列挙型の基になる型の配列または基になる型が同じ別の列挙型の配列の間にも、変換が存在します。

```vb
Enum Color As Byte
    Red
    Green
    Blue
End Enum

Module Test
    Sub Main()
        Dim a(10) As Color
        Dim b() As Integer
        Dim c() As Byte

        b = a    ' Error: Integer is not the underlying type of Color
        c = a    ' OK
        a = c    ' OK
    End Sub
End Module
```

この例では、@no__t 0 の配列は、`Byte`、`Color` の基になる型の配列との間で変換されます。 ただし、`Integer` は `Color` の基になる型ではないため、`Integer` の配列への変換はエラーになります。

@No__t-0 型のランク-1 配列には、次のいずれかの条件が満たされている限り、`IList(Of B)`、`IReadOnlyList(Of B)`、`ICollection(Of B)`、`IReadOnlyCollection(Of B)`、`IEnumerable(Of B)` のコレクションインターフェイス型への配列変換が含まれています。

- `A` および `B` は、値型として知られていない参照型または型パラメーターの両方です。と `A` には、`B` に変換された参照、配列、または型パラメーターがあります。もしくは
- `A` および `B` は、基になる同じ型の列挙型です。もしくは
- `A` および `B` の1つは列挙型であり、もう一方は基になる型です。

また、任意のランクを持つ A 型の配列には、非ジェネリックコレクションインターフェイス型への配列変換が含まれています。 `IList`、`ICollection`、`IEnumerable` (`System.Collections`)。

@No__t-0 を使用するか、@no__t 1 つのメソッドを直接呼び出すことによって、結果のインターフェイスを反復処理することができます。 ランク1の配列が変換されたジェネリックまたは非ジェネリック形式の `IList` または `ICollection` の場合、インデックスを使用して要素を取得することもできます。 ランク1の配列が汎用または非ジェネリックの `IList` に変換された場合は、前に説明したのと同じランタイム配列の共変性のチェックに従って、インデックスを使用して要素を設定することもできます。 他のすべてのインターフェイスメソッドの動作は、VB 言語仕様によって定義されていません。これは、基になるランタイムによって作成されます。

## <a name="value-type-conversions"></a>値型の変換

値型の値は、その基本参照型または*ボックス*化と呼ばれるプロセスによって実装されるインターフェイス型のいずれかに変換できます。 値型の値がボックス化されている場合、値は .NET Framework ヒープ上に存在する場所からコピーされます。 次に、ヒープ上のこの場所への参照が返され、参照型の変数に格納できます。 この参照は、値型の*ボックス*化されたインスタンスとも呼ばれます。 ボックス化されたインスタンスは、値型ではなく、参照型と同じセマンティクスを持ちます。

ボックス化された値型は、*ボックス化解除*と呼ばれるプロセスを使用して、元の値型に変換できます。 ボックス化された値型がボックス化解除されると、値がヒープから変数の場所にコピーされます。 その時点から、値型であるかのように動作します。 値型のボックス化を解除するときは、値が null 値または値型のインスタンスである必要があります。 それ以外の場合は、`System.InvalidCastException` 例外がスローされます。 値が列挙型のインスタンスである場合、その値は列挙型の基になる型または基になる型が同じ別の列挙型にボックス化解除することもできます。 Null 値は、リテラル @no__t 0 として扱われます。

Null 許容値型を適切にサポートするために、ボックス化とボックス化解除を行うときに、値型 `System.Nullable(Of T)` が特別に処理されます。 型 `Nullable(Of T)` の値をボックス化すると、値の `HasValue` プロパティ @no__t が-3 の場合は-1、値の `HasValue` プロパティが @no__t の場合は-4 の値が @no__t、型のボックス化された値になります。 型の値 `T` から `Nullable(Of T)` にボックス化解除すると、`Value` プロパティがボックス化された値であり、`HasValue` プロパティが `True` @no__t のインスタンスになります。 値 `Nothing` は、任意の @no__t に対して `Nullable(Of T)` にボックス化解除できます。結果として、`HasValue` プロパティが `False` である値が生成されます。 ボックス化された値型は参照型と同じように動作するため、同じ値への複数の参照を作成することができます。 プリミティブ型と列挙型では、これらの型のインスタンスが*不変*であるため、これは関係ありません。 つまり、これらの型のボックス化されたインスタンスを変更することはできないため、同じ値への複数の参照があるという事実を観察することはできません。

一方、構造体は、そのインスタンス変数がアクセス可能である場合、またはそのメソッドやプロパティがインスタンス変数を変更する場合に、変更可能な場合があります。 ボックス化された構造体への1つの参照を使用して構造体を変更すると、ボックス化された構造体へのすべての参照に変更が表示されます。 この結果は予期しない結果になる可能性があるため、`Object` として型指定された値がある場所から別の場所にコピーされると、参照がコピーされるだけでなく、ヒープ上で自動的に複製されます。 以下に例を示します。

```vb
Class Class1
    Public Value As Integer = 0
End Class

Structure Struct1
    Public Value As Integer
End Structure

Module Test
    Sub Main()
        Dim val1 As Object = New Struct1()
        Dim val2 As Object = val1

        val2.Value = 123

        Dim ref1 As Object = New Class1()
        Dim ref2 As Object = ref1

        ref2.Value = 123

        Console.WriteLine("Values: " & val1.Value & ", " & val2.Value)
        Console.WriteLine("Refs: " & ref1.Value & ", " & ref2.Value)
    End Sub
End Module
```

プログラムの出力は次のようになります。

```console
Values: 0, 123
Refs: 123, 123
```

ローカル変数のフィールドへの割り当ては、ローカル変数のフィールドには影響しません。この場合、ボックス化された `Struct1` が `val2` に割り当てられたときに、値のコピーが作成されているため、ローカル変数のフィールド `val1` @no__t 影響を与えません。 これに対し、`ref2.Value = 123` の割り当ては、`ref1` と @no__t 2 の両方が参照するオブジェクトに影響します。

__付箋.__ @No__t-0 として型指定された構造体の場合、構造体のコピーは実行されません。これは `System.ValueType` の遅延バインディングができないためです。

ルールには、ボックス化された値の型が割り当て時にコピーされるという例外が1つあります。 ボックス化された値型参照が別の型に格納されている場合、内部参照はコピーされません。 以下に例を示します。

```vb
Structure Struct1
    Public Value As Object
End Structure

Module Test
    Sub Main()
        Dim val1 As Struct1
        Dim val2 As Struct1

        val1.Value = New Struct1()
        val1.Value.Value = 10

        val2 = val1
        val2.Value.Value = 123
        Console.WriteLine("Values: " & val1.Value.Value & ", " & _
            val2.Value.Value)
    End Sub
End Module
```

プログラムの出力は次のようになります。

```console
Values: 123, 123
```

これは、値をコピーするときに、ボックス化された内部の値がコピーされないためです。 したがって、`val1.Value` と `val2.Value` の両方に、同じボックス化された値型への参照が含まれています。

__付箋.__ 内部のボックス化された値型がコピーされないという事実は、.NET 型システムの制限であり、すべての内部のボックス化された値型がコピーされていることを確認するために、`Object` の値がコピーされたときには非常に負荷がかかることがあります。

既に説明したように、ボックス化された値型は、元の型にのみボックス化を解除できます。 ただし、ボックス化されたプリミティブ型は、`Object` として型指定されると、特別に扱われます。 これらは、変換先の他のプリミティブ型に変換できます。 以下に例を示します。

```vb
Module Test
    Sub Main()
        Dim o As Object = 5
        Dim b As Byte = CByte(o)  ' Legal
        Console.WriteLine(b) ' Prints 5
    End Sub
End Module
```

通常、ボックス化された @no__t 0 値 `5` は、`Byte` 変数にボックス化解除できませんでした。 ただし、`Integer` と `Byte` はプリミティブ型であり、変換が可能であるため、変換は許可されます。

値型をインターフェイスに変換することは、インターフェイスに制約される汎用引数とは異なることに注意してください。 制約付き型パラメーターのインターフェイスメンバーにアクセスする (または `Object` でメソッドを呼び出す) と、値型がインターフェイスに変換され、インターフェイスメンバーにアクセスするときと同様に、ボックス化が発生しません。 たとえば、@no__t 0 のインターフェイスに、値を変更するために使用できるメソッド `Increment` が含まれているとします。 @No__t-0 が制約として使用されている場合、`Increment` メソッドの実装は、ボックス化されたコピーではなく `Increment` が呼び出された変数への参照を使用して呼び出されます。

```vb
Interface ICounter
    Sub Increment()
    ReadOnly Property Value() As Integer
End Interface

Structure Counter
    Implements ICounter

    Dim _value As Integer

    Property Value() As Integer Implements ICounter.Value
        Get
            Return _value
        End Get
    End Property

    Sub Increment() Implements ICounter.Increment
       value += 1
    End Sub
End Structure

Module Test
      Sub Test(Of T As ICounter)(x As T)
         Console.WriteLine(x.value)
         x.Increment()                     ' Modify x
         Console.WriteLine(x.value)
         CType(x, ICounter).Increment()    ' Modify boxed copy of x
         Console.WriteLine(x.value)
      End Sub

      Sub Main()
         Dim x As Counter
         Test(x)
      End Sub
End Module
```

@No__t-0 の最初の呼び出しでは、変数 `x` の値が変更されます。 これは `Increment` への2回目の呼び出しと同じではありません。この場合、`x` のボックス化されたコピーの値が変更されます。 このため、プログラムの出力は次のようになります。

```console
0
1
1
```

### <a name="nullable-value-type-conversions"></a>Null 許容値型の変換

値の型 `T` は、型の null 許容バージョン (`T?`) との間で変換を行うことができます。 変換される値 @no__t が-3 の場合、`T?` から `T` への変換は `System.InvalidOperationException` 例外をスローします。 また、`T?` の場合は、`T` に `S` への組み込みの変換がある場合は、型 `S` に変換されます。 @No__t-0 が値型の場合、`T?` と `S?` の間に次の組み込み変換が存在します。

* 同じ分類 (縮小または拡大) から `T?` への変換 (`S?`)。

* 同じ分類 (縮小または拡大) から `T` への変換 (`S?`)。

* @No__t-0 から `T` への縮小変換。

たとえば、組み込みの拡大変換は `Integer?` から `Long?` の間に存在します。これは、組み込みの拡大変換が @no__t から `Long` に存在するためです。

```vb
Dim i As Integer? = 10
Dim l As Long? = i
```

@No__t-0 から `S?` に変換する場合、`T?` の値が `Nothing` の場合、`S?` の値は `Nothing` になります。 @No__t-0 から `T` または `T?` から `S` に変換する場合、`T?` または `S?` の値が @no__t の場合は、@no__t 7 の例外がスローされます。

基になる型 `System.Nullable(Of T)` の動作により、null 許容値型 `T?` がボックス化されている場合、結果は @no__t 型のボックス化された値であり、型 `T?` のボックス化された値ではありません。 逆に、null 許容値型にボックス化を解除すると `T?` の場合、値は `System.Nullable(Of T)` によってラップされ、`Nothing` は、型 `T?` の null 値にボックス化解除されます。 以下に例を示します。

```vb
Dim i1? As Integer = Nothing
Dim o1 As Object = i1

Console.WriteLine(o1 Is Nothing)                    ' Will print True
o1 = 10
i1 = CType(o1, Integer?)
Console.WriteLine(i1)                               ' Will print 10
```

この動作の副作用として、値型をインターフェイスに変換するには、型をボックス化する必要があるため、`T` のすべてのインターフェイスを実装するには、null 許容型の値型 `T?` になります。 その結果、`T?` は、`T` が変換可能なすべてのインターフェイスに変換できます。 ただし、null 許容値型 `T?` は、ジェネリック制約チェックまたはリフレクションのために `T` のインターフェイスを実際に実装していないことに注意する必要があります。 以下に例を示します。

```vb
Interface I1
End Interface

Structure T1
    Implements I1
    ...
End Structure

Module Test
    Sub M1(Of T As I1)(ByVal x As T)
    End Sub

    Sub Main()
        Dim x? As T1 = Nothing
        Dim y As I1 = x                ' Valid
        M1(x)                          ' Error: x? does not satisfy I1 constraint
    End Sub
End Module
```

## <a name="string-conversions"></a>文字列の変換

@No__t-0 を `String` に変換すると、最初の文字が文字値である文字列が返されます。 @No__t-0 を `Char` に変換すると、文字列の最初の文字が値である文字が返されます。 @No__t-0 の配列を `String` に変換すると、配列の要素を文字として持つ文字列が生成されます。 @No__t-0 を `Char` の配列に変換すると、文字列の文字を要素とする文字配列が生成されます。

@No__t-0 と `Boolean`、`Byte`、`SByte`、`UShort`、`Short`、`UInteger`、`Integer`、`ULong`、`Long`、0、1、2、3、およびその逆の正確な変換は、この仕様の範囲を超えています。実装は、1つの詳細の例外に依存します。 文字列変換では、常に実行時環境の現在のカルチャが考慮されます。 そのため、実行時に実行する必要があります。

## <a name="widening-conversions"></a>拡大変換

拡大変換ではオーバーフローは発生しませんが、精度が失われる可能性があります。 次の変換は、拡大変換です。

__Id/既定の変換__

* 型からそれ自体へ。

* 同じシグネチャを持つ任意のデリゲート型に対してラムダメソッドを再分類するために生成された匿名デリゲート型から。

* リテラルの `Nothing` から型になります。

__数値変換__

* @No__t-0 から `UShort`、`Short`、`UInteger`、`Integer`、`ULong`、`Long`、`Decimal`、`Single`、または `Double`。

* @No__t-0 から `Short`、`Integer`、`Long`、`Decimal`、`Single`、または `Double`。

* @No__t-0 から `UInteger`、`Integer`、`ULong`、`Long`、`Decimal`、`Single`、または `Double`。

* @No__t-0 から `Integer`、`Long`、`Decimal`、`Single`、`Double` のいずれかになります。

* @No__t-0 から `ULong`、`Long`、`Decimal`、`Single`、または `Double`。

* @No__t-0 から `Long`、`Decimal`、`Single`、または `Double`。

* @No__t-0 から `Decimal`、`Single`、または `Double`。

* @No__t-0 から `Decimal`、`Single` または `Double` です。

* @No__t-0 から `Single` または `Double` です。

* @No__t-0 から `Double` です。

* リテラルから `0` を列挙型にします。 (__注:__ @No__t-0 から任意の列挙型への変換は、テストフラグを簡略化するために拡大されます。 たとえば、`Values` は、値 `One` を持つ列挙型である場合、@no__t を示すことにより、型 `Values` の変数 @no__t をテストできます)。

* 列挙型から基になる数値型、または基になる数値型からへの拡大変換がある数値型。

* 定数式の値が変換先の型の範囲内にある場合、型の定数式 `ULong`、`Long`、`UInteger`、`Integer`、`UShort`、`Short`、`Byte`、または `SByte` をより狭い型にします。 (__注:__ @No__t-0 または `Integer` から `Single`、`ULong`、`Long` から `Single` または `Double` への変換または `Double` から `Single` または  への変換は、精度の低下を招く可能性がありますが、マグニチュードが失われることはありません。 その他の拡大数値変換では、情報が失われることはありません)。

__参照変換__

* 参照型から基本型への。

* 型がインターフェイスまたは variant 互換インターフェイスを実装している場合は、参照型からインターフェイス型への。

* インターフェイス型から `Object` になります。

* インターフェイス型から variant 互換のインターフェイス型へ。

* デリゲート型から variant 互換のデリゲート型へ。 (__注:__ その他の多くの参照変換は、これらの規則によって暗黙的に示されます。 たとえば、匿名デリゲートは `System.MulticastDelegate` から継承する参照型です。配列型は `System.Array` から継承する参照型です。匿名型は、`System.Object` から継承する参照型です)。

__匿名デリゲートの変換__

* ラムダメソッドをより広範なデリゲート型に再分類するために生成された匿名デリゲート型から。

__配列の変換__

* 要素型を持つ配列型から `S` の場合は、要素型が-1 @no__t @no__t-@no__t 2 になります。この場合、次のすべてが満たされます。

  * `S` および `T` は要素の型のみが異なります。

  * @No__t-0 と `Te` はどちらも参照型であるか、参照型であると認識される型パラメーターです。

  * 拡大参照、配列、または型パラメーターの変換が `Se` から `Te` に存在します。

* 配列型から、列挙された要素型を持つ-0 `Se` @no__t、要素 @no__t 型が-1 の配列 @no__t 型になります。次のすべてが満たされているとします。

  * `S` および `T` は要素の型のみが異なります。

  * `Te` は `Se` の基になる型です。

* 次のいずれかの条件に該当する場合は、ランク1の配列型から、要素の種類として列挙された要素の型 `Se`、`System.Collections.Generic.IList(Of Te)`、`IReadOnlyList(Of Te)`、`ICollection(Of Te)`、`IReadOnlyCollection(Of Te)`、および @no__t の @no__t ます。

  * @No__t-0 と `Te` の両方が参照型であるか、参照型であることがわかっている型パラメーターであり、拡大参照、配列、または型パラメーターの変換が `Se` から `Te` に存在します。もしくは

  * `Te` は `Se` の基になる型です。もしくは

  * `Te` は `Se` と同じ

__値型の変換__

* 値型から基本型への。

* 値型から、型が実装するインターフェイス型になります。

__Null 許容値型の変換__

* 型から `T` `T?` の型になります。

* 型から-0 @no__t 型 `S?` に変換されます。ここで、型から @no__t 型 @no__t への拡大変換があります。

* 型から-0 @no__t 型 `S?` に変換されます。ここで、型から @no__t 型 @no__t への拡大変換があります。

* 型 `T?` は、型 `T` が実装するインターフェイス型になります。

__文字列変換__

* @No__t-0 から `String` です。

* @No__t-0 から `String` です。

__型パラメーターの変換__

* 型パラメーターから `Object` になります。

* 型パラメーターからインターフェイス型制約、またはインターフェイス型制約と互換性のあるインターフェイスバリアント。

* 型パラメーターから、クラス制約によって実装されるインターフェイスへの。

* 型パラメーターから、クラス制約によって実装されるインターフェイスと互換性のあるインターフェイスバリアントへの通信。

* 型パラメーターからクラス制約への、またはクラス制約の基本型。

* 型パラメーター `T` から型パラメーターの制約 `Tx`、またはすべての @no__t がに拡大変換されています。

## <a name="narrowing-conversions"></a>縮小変換

縮小変換は、常に成功するとは限りません。情報が失われる可能性がある変換、型のドメイン間での変換は、縮小表記という意味で十分に異なる変換です。 次の変換は縮小変換として分類されます。

__ブール型変換__

* @No__t-0 から `Byte`、`SByte`、`UShort`、`Short`、`UInteger`、`Integer`、`ULong`、`Long`、`Decimal`、0、または 1。

* @No__t-0、`SByte`、`UShort`、`Short`、`UInteger`、`Integer`、`ULong`、`Long`、`Decimal`、`Single`、または 0 から 1。

__数値変換__

* @No__t-0 から `SByte` です。

* @No__t-0 から `Byte`、`UShort`、`UInteger`、または `ULong`。

* @No__t-0 から `Byte`、`SByte`、または `Short`。

* @No__t-0 から `Byte`、`SByte`、`UShort`、`UInteger`、または `ULong`。

* @No__t-0 から `Byte`、`SByte`、`UShort`、`Short`、または `Integer`。

* @No__t-0 から `Byte`、`SByte`、`UShort`、`Short`、`UInteger`、または `ULong`。

* @No__t-0 から `Byte`、`SByte`、`UShort`、`Short`、`UInteger`、`Integer`、または `Long`。

* @No__t-0 から `Byte`、`SByte`、`UShort`、`Short`、`UInteger`、`Integer`、または `ULong`。

* @No__t-0 から `Byte`、`SByte`、`UShort`、`Short`、`UInteger`、`Integer`、`ULong`、または `Long`。

* @No__t-0 から `Byte`、`SByte`、`UShort`、`Short`、`UInteger`、`Integer`、`ULong`、`Long`、または `Decimal`。

* @No__t-0 から `Byte`、`SByte`、`UShort`、@no__t 4、`UInteger`、`Integer`、`ULong`、`Long`、`Decimal`、または 0。

* 数値型から列挙型への。

* 列挙型から数値型への変換では、基になる数値型がに縮小変換されます。

* 列挙型から別の列挙型へ。

__参照変換__

* 参照型からより派生した型への。

* クラス型がインターフェイス型またはそれと互換性のあるインターフェイス型バリアントを実装していない場合、クラス型からインターフェイス型になります。

* インターフェイス型からクラス型へ。

* 2つの型の間に継承関係がなく、バリアントとの互換性がない場合は、インターフェイス型から別のインターフェイス型にします。

__匿名デリゲートの変換__

* 任意の幅の狭いデリゲート型に再分類するラムダメソッドに対して生成された匿名デリゲート型から。

__配列の変換__

* 次のすべての条件に該当する場合は、要素型が-1 の配列型の場合は、要素型が-1 の配列型 `T` の場合は、要素型が `Te` の場合は @no__t-@no__t になります。

  * `S` および `T` は要素の型のみが異なります。
  * @No__t-0 と `Te` の両方が参照型であるか、または値型として知られていない型パラメーターです。
  * 縮小参照、配列、または型パラメーターの変換が `Se` から `Te` に存在します。

* 配列型から要素型を `S` にすると、-1 @no__t、列挙された要素 @no__t 型を持つ `T` になります。この場合、次のすべてが満たされます。

  * `S` および `T` は要素の型のみが異なります。
  * `Se` は `Te` の基になる型であるか、または基になる型が同じである列挙型の両方が異なることを示します。

* 次のいずれかの条件に該当する場合は、ランク1の配列型から、列挙された要素の型 `Se`、`IList(Of Te)`、`IReadOnlyList(Of Te)`、`ICollection(Of Te)`、`IReadOnlyCollection(Of Te)`、`IEnumerable(Of Te)` を持つランク1の @no__t ます。

  * @No__t-0 と `Te` の両方が参照型であるか、参照型であることがわかっている型パラメーターであり、縮小参照、配列、または型パラメーターの変換が `Se` から `Te` に存在します。もしくは
  * `Se` は `Te` の基になる型であるか、または基になる型が同じである列挙型の両方が異なることを示します。

__値型の変換__

* 参照型からより多くの派生値型へ。

* 値型がインターフェイス型を実装している場合は、インターフェイス型から値型になります。

__Null 許容値型の変換__

* 型から-0 @no__t 型 `T` です。

* 型から-0 @no__t 型 `S?` に変換されます。ここで、@no__t 型から型 @no__t への縮小変換があります。

* 型から-0 @no__t 型 `S?` に変換されます。ここで、@no__t 型から型 @no__t への縮小変換があります。

* 型から-0 @no__t 型 `T` に変換されます。ここで、型から型 @no__t への変換が @no__t ます。

__文字列変換__

* @No__t-0 から `Char` です。

* @No__t-0 から `Char()` です。

* @No__t-0 から `Boolean`、`Boolean` から `String` です。

* @No__t-0 と `Byte`、`SByte`、`UShort`、`Short`、`UInteger`、`Integer`、`ULong`、`Long`、`Decimal`、0、1 の間の変換。

* @No__t-0 から `Date`、`Date` から `String` です。

__型パラメーターの変換__

* @No__t-0 から型パラメーターへ。

* 型パラメーターがインターフェイスに制約されていない場合、または、そのインターフェイスを実装するクラスに制約されている場合、型パラメーターからインターフェイス型になります。

* インターフェイス型から型パラメーターへ。

* 型パラメーターから、クラス制約の派生型にします。

* 型パラメーター `T` から @no__t 型パラメーターの制約に対しては、への縮小変換があります。

## <a name="type-parameter-conversions"></a>型パラメーターの変換

型パラメーターの変換は、制約 (存在する場合) によって決定されます。 型パラメーター `T` は、常にそれ自体に変換することができます。また、`Object`、およびインターフェイス型との間でいつでも変換できます。 型 `T` が実行時に値型である場合、`T` から `Object` へ、またはインターフェイス型からへの変換はボックス化変換であり、`Object` またはインターフェイス型から @no__t への変換は、ボックス化変換になります。 クラスの制約が指定された型パラメーター `C` は、型パラメーターから `C` とその基本クラスに対する追加の変換を定義します (その逆も同様)。 型パラメーターの制約が指定された `T` `Tx` は、`Tx` への変換を定義し、すべての @no__t をに変換します。

要素型がインターフェイス制約を持つ型パラメーターである配列 `I` は、要素型が `I` である配列と同じ共変配列変換を持ちます。これは、型パラメーターにも @no__t 2 またはクラスの制約があるためです (参照のみであるため)。配列要素の型は共変にすることができます。 要素型がクラス制約を持つ型パラメーターである配列 `C` は、要素型が `C` である配列と同じ共変配列変換を持ちます。

上記の変換規則では、制約のない型パラメーターから非インターフェイス型への変換は許可されていません。 その理由は、このような変換のセマンティクスについて混乱が生じないようにするためです。 たとえば、次のような宣言があるとします。

```vb
Class X(Of T)
    Public Shared Function F(t As T) As Long 
        Return CLng(t)    ' Error, explicit conversion not permitted
    End Function
End Class
```

@No__t-0 から `Integer` への変換が許可されている場合、`X(Of Integer).F(7)` が `7L` を返すことが簡単であると考えられます。 ただし、数値変換はコンパイル時に型が数値であることがわかっている場合にのみ考慮されます。 このようなセマンティクスを明確にするために、上記の例を記述する必要があります。

```vb
Class X(Of T)
    Public Shared Function F(t As T) As Long
        Return CLng(CObj(t))    ' OK, conversions permitted
    End Function
End Class
```

## <a name="user-defined-conversions"></a>ユーザー定義の変換

*組み込み変換*は、言語によって定義された変換 (この仕様ではリスト) であり、*ユーザー定義の変換*は `CType` 演算子のオーバーロードによって定義されます。 型の間で変換を行う場合、組み込みの変換が適用されない場合は、ユーザー定義の変換が考慮されます。 ソースとターゲットの型に*最も固有*なユーザー定義の変換がある場合は、ユーザー定義の変換が使用されます。 それ以外の場合は、コンパイル時のエラーが発生します。 最も具体的な変換は、変換元の型に "最も近い" オペランドがあり、結果の型がターゲットの型に "最も近い" である変換です。 使用するユーザー定義の変換を決定するときに、最も具体的な拡大変換が使用されます。拡大変換が最も限定的でない場合は、最も限定的な縮小変換が使用されます。 特定の縮小変換がない場合、変換は定義されず、コンパイル時エラーが発生します。

以下のセクションでは、最も具体的な変換がどのように決定されるかについて説明します。 次の用語を使用します。

型 `A` から型 `B` への組み込みの拡大変換が存在し、`A` と `B` のどちらもインターフェイスではない場合、@no__t- *4 は @no__t*に含まれ、@no__t には `A` が*含ま*れます。

型のセットの中で*最も外側*にある型は、セット内の他のすべての型を含む1つの型です。 1つの型に他のすべての型が含まれていない場合、そのセットには最も外側の型がありません。 直感的に言うと、最も外側の型は、セット内の "最大" 型です。これは、他の型を拡大変換することによって変換できる1つの型です。

型のセットの中で*最も内側*にある型は、セット内の他のすべての型に包含されている型です。 他のすべての型に包含されている型がない場合は、そのセットに最も包含されていない型はありません。 直感的に言うと、最も包含されている型は、セット内の "最小" 型です。これは、縮小変換を通じて他の型に変換できる1つの型です。

@No__t 型に対してユーザー定義の候補変換を収集する場合は、`T` で定義されているユーザー定義の変換演算子を代わりに使用します。 変換先の型が null 許容の値型でもある場合、null 非許容の値型のみを含むユーザー定義の変換演算子 @no__t はすべてリフトされます。 @No__t-0 から `S` への変換演算子は、`T?` から `S?` への変換として解除され、必要に応じて `T?` を @no__t に変換して評価します。また、必要に応じて、`T` から `S` へのユーザー定義変換演算子を評価し、必要に応じて `S` を @no__t に変換します。 ただし、変換される値が `Nothing` の場合、リフトされた変換演算子は `S?` として型指定された @no__t の値に直接変換します。 以下に例を示します。

```vb
Structure S
    ...
End Structure

Structure T
    Public Shared Widening Operator CType(ByVal v As T) As S
        ...
    End Operator
End Structure

Module Test
    Sub Main()
        Dim x As T?
        Dim y As S?

        y = x                ' Legal: y is still null
        x = New T()
        y = x                ' Legal: Converts from T to S
    End Sub
End Module
```

変換を解決する際には、リフトされた変換演算子よりもユーザー定義の変換演算子を使用することをお勧めします。 以下に例を示します。

```vb
Structure S
    ...
End Structure

Structure T
    Public Shared Widening Operator CType(ByVal v As T) As S
        ...
    End Operator

    Public Shared Widening Operator CType(ByVal v As T?) As S?
        ...
    End Operator
End Structure

Module Test
    Sub Main()
        Dim x As T?
        Dim y As S?

        y = x                ' Calls user-defined conversion, not lifted conversion
    End Sub
End Module
```

実行時にユーザー定義の変換を評価するには、次の3つの手順を実行します。

1. まず、必要に応じて、組み込みの変換を使用して、変換元の型からオペランドの型に値を変換します。

2. 次に、ユーザー定義の変換が呼び出されます。

3. 最後に、必要に応じて、組み込みの変換を使用して、ユーザー定義の変換の結果を対象の型に変換します。

ユーザー定義の変換の評価では、複数のユーザー定義変換演算子が含まれないことに注意する必要があります。

### <a name="most-specific-widening-conversion"></a>最も限定的な拡大変換

次の手順を使用して、2つの型の間で、ユーザー定義の拡大変換演算子のうち最も限定的なものを決定します。

1. まず、候補となる変換演算子がすべて収集されます。 候補の変換演算子は、ソース型のすべてのユーザー定義の拡大変換演算子と、対象の型のすべてのユーザー定義の拡大変換演算子です。

2. 次に、適用できないすべての変換演算子がセットから削除されます。 変換演算子は、ソース型からオペランド型への組み込みの拡大変換演算子が存在し、演算子の結果からターゲット型への組み込みの拡大変換演算子が存在する場合に、ソースの型とターゲットの型に適用されます。 適用可能な変換演算子がない場合、特定の拡大変換は行われません。

3. 次に、適用可能な変換演算子の最も限定的なソースの種類が決定されます。

   * 変換演算子のいずれかが変換元の型から直接変換する場合、変換元の型は最も限定的なソースの種類です。

   * それ以外の場合、最も限定的なソースの種類は、変換演算子のソース型の組み合わせで最も包含される型です。 包含されている型の中に最も多くの包含型が見つからない場合は、特に特定の拡大変換はありません。

4. 次に、適用可能な変換演算子の最も限定的なターゲットの種類を決定します。

   * 変換演算子のいずれかがターゲット型に直接変換される場合、対象の型は最も限定的なターゲット型です。

   * それ以外の場合、最も限定的なターゲット型は、変換演算子の対象の型の組み合わせで最も外側にある型になります。 最も外側の型が見つからない場合、特定の拡大変換は行われません。

5. その後、ただ1つの変換演算子が最も具体的な変換元の型から最も限定的なターゲット型に変換する場合は、これが最も具体的な変換演算子です。 このような演算子が複数存在する場合、特定の拡大変換は行われません。

### <a name="most-specific-narrowing-conversion"></a>最も限定的な縮小変換

次の手順に従って、2つの型の間で最も限定的なユーザー定義の縮小変換演算子を決定します。

1. まず、候補となる変換演算子がすべて収集されます。 候補の変換演算子は、変換元の型のすべてのユーザー定義変換演算子と、対象の型のすべてのユーザー定義変換演算子です。

2. 次に、適用できないすべての変換演算子がセットから削除されます。 変換演算子は、ソース型からオペランド型への組み込みの変換演算子が存在し、演算子の結果からターゲット型への組み込みの変換演算子がある場合に、ソース型およびターゲット型に適用されます。 適用可能な変換演算子がない場合、特定の縮小変換は行われません。

3. 次に、適用可能な変換演算子の最も限定的なソースの種類が決定されます。

   * 変換演算子のいずれかが変換元の型から直接変換する場合、変換元の型は最も限定的なソースの種類です。

   * それ以外の場合、変換演算子のいずれかが、変換元の型を含む型から変換する場合、最も限定的なソース型は、それらの変換演算子のソース型の組み合わせに含まれる最も包含された型になります。 包含されていない型がほとんど見つからない場合、特定の縮小変換は行われません。

   * それ以外の場合、最も限定的なソースの種類は、変換演算子のソース型の組み合わせで最も外側にある型になります。 最も外側の型が見つからない場合、特定の縮小変換は行われません。

4. 次に、適用可能な変換演算子の最も限定的なターゲットの種類を決定します。

   * 変換演算子のいずれかがターゲット型に直接変換される場合、対象の型は最も限定的なターゲット型です。

   * それ以外の場合、変換演算子のいずれかが、対象の型によって包含されている型に変換される場合、最も限定的なターゲット型は、それらの変換演算子のソース型の組み合わせで最も外側にある型になります。 最も外側の型が見つからない場合、特定の縮小変換は行われません。

   * それ以外の場合、最も限定的なターゲット型は、変換演算子の対象の型の組み合わせで最も包含される型です。 包含されていない型がほとんど見つからない場合、特定の縮小変換は行われません。

5. その後、ただ1つの変換演算子が最も具体的な変換元の型から最も限定的なターゲット型に変換する場合は、これが最も具体的な変換演算子です。 このような演算子が複数存在する場合、特定の縮小変換は行われません。

## <a name="native-conversions"></a>ネイティブ変換

一部の変換は、.NET Framework によってネイティブにサポートされているため、*ネイティブ変換*として分類されます。 これらの変換は、`DirectCast` および `TryCast` 変換演算子とその他の特殊な動作を使用することによって最適化できるものです。 ネイティブ変換として分類される変換は、id 変換、既定の変換、参照変換、配列の変換、値型の変換、および型パラメーターの変換です。

## <a name="dominant-type"></a>優先する型

型のセットを指定した場合、通常は、型の推定などの状況で、セットの優先度の*高い型*を判断する必要があります。 型のセットの優先される型は、1つ以上の他の型が暗黙的に変換されていない型を最初に削除することによって決定されます。 この時点で型がない場合は、優先度の高い型はありません。 最も優先される型は、残りの型の最も内側の型になります。 最も包含されている型が複数ある場合は、優先度の高い型はありません。
